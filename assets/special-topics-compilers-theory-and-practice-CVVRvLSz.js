const e={isDeprecated:!1,description:"The objective of this course is to learn the theory and practice behind building automatic translators (compilers) for higher level programming languages and to engineer and build key phases of a compiler in Java or C++ for a small language.",tags:[],creditHours:3,_rev:"iLpqNfBINCDhaBRaVOIQFb",syllabus:{file:{_type:"file",asset:{_ref:"file-2a3b73f95d5e5390180895afd5fb351ea81d2a8a-pdf",_type:"reference"}}},codes:["CS-8803-O08"],textbooks:[{name:"Engineering: A Compiler, 2nd Edition",_key:"b9cb48094e408f78e908b271982d93ab",url:"https://amzn.to/3Km7ARa"}],_updatedAt:"2022-08-25T21:43:05Z",isFoundational:!0,name:"Special Topics: Compilers - Theory and Practice",id:"external-import-CS-8803-O08",_createdAt:"2022-07-05T23:23:15Z",programs:[{_ref:"b6f2bf84-c2ea-405e-8423-c348e1a94051",_type:"reference",_key:"4b68c18c6021"}],_type:"course",officialURL:"https://omscs.gatech.edu/cs-8803-o08-compilers-theory-and-practice",_id:"external-import-CS-8803-O08",slug:"special-topics-compilers-theory-and-practice",reviewCount:23,rating:4.130434782608695,difficulty:4.6521739130434785,workload:28.782608695652176,reviews:[{user:"qijT54rwyDuqUGRJr6it6A==",reviewDate:"August 4, 2024",semester:"summer 2024",review:`This is easily the best course I've taken so far. I would highly recommend this course to everyone who is taking systems specialization. It's a shame that it isn't a core course.
Content:
As with most OMSCS courses, this one is about breadth. It emphasizes both - theory and practice. I knew very little about compilers and came away with a solid understanding of various components. I think the only part that is outdated is the attribute grammar framework. The third edition of the textbook doesn't even mention it. Lectures are okay, although they mostly follow the textbook.
TAs:
The TAs are the primary reason why this course is outstanding. They are highly knowledgeable about the subject and are genuinely enthusiastic about teaching. Most of the questions are resolved very quickly. There is a fast turnaround time for grading - one week at the most and even shorter around institute deadlines like withdrawal and grading dates.
Homework:
Don't take this one lightly. The questions are quite challenging. I recommend writing code to solve them, and verify answers. For the liveness analysis, the code you write will also be helpful for Project.
Project:
In summer there are three phases - 1) Generate Parse Tree 2) Generate IR 3) Generate MIPS assembly. The difference from a full semester is that you don't have to handle floats, and you don't have to handle one register allocation algorithm. In hindsight I should have taken this course in a full semester. But I'm interested in some other high workload courses that aren't offered in the summer.
The great thing about the project is that all the tests are given to you up front. If you pass the autograder tests, and don't do anything obviously incorrect to bypass them, you will know how you perform right away. There is no submission limit, you get feedback in under a minute, and you're actually encouraged to submit early and frequently while you implement various functionalities.
There is zero starter code and a single dependency - ANTLR4. Other than that it's up to you how to implement the compiler. You don't get this level of design and implementation freedom often.
Final:
The final was a bit difficult for me. There was one significantly challenging question that I just didn't have enough time for. Also, given the amount of effort one has to put in the homework and project, the final has way too much weight. I think 25% would be a fair amount. I would recommend completing the extra credit portion in the Project, even though I didn't do it. It's worth 5 points in the finals, and gives you enough leeway for a grade.`,rating:5,difficulty:5,workload:28},{user:"yM5flpsoDbCzSiqfOIGgpQ==",reviewDate:"July 31, 2024",semester:"summer 2024",review:`Final grade: A. I took GIOS + AI in my first Spring semester 2024, which averaged 15-20 hrs/week together.
Compilers in Summer semester 2024 was more challenging than those two courses combined, needing 25 hrs/week, especially in phases 2 and 3. Phase 1 was much lighter in comparison.
This was my first time using Java for a project, but I had a few years of coding experience prior. You'll be forced to get good at Java fast (or C++). My compiler project totaled 5k lines (not counting autogenerated ANTLR4 code): ~200 for phase 1, 2000 for phase 2, and 2800 for phase 3.
Tip: Code your liveness analysis for phase 3 and use it to check homework 3 answers. Do not do it manually.
The final exam was okay, difficulty-wise. I highly recommend this course. You learn theory and apply it in the project to build a compiler from scratch.`,rating:5,difficulty:5,workload:25},{user:"SSSOP28ZCXJKKGVI/KdIhg==",reviewDate:"May 19, 2024",semester:"spring 2024",review:`This course is very difficult, but totally worthwhile.
I found Distributed Systems to be significantly easier than this course, though if I had to pick between the two I'd probably pick Compilers since it was so much fun. I paired this class with Software Analysis and the two worked well together. Software Analysis goes over some of the same concepts like dataflow analysis. Software Analysis also tapers off in difficulty around the last two phases of Compilers which is nice.
You'll build a compiler from scratch in either C++ or Java. You use ANTLR to handle scanning/parsing, but everything else is totally your design.
The project is split up into phases. Each phase you build upon your compiler to add some new functionality. The auto-grader on Gradescope gives you a very good idea of where you're at.
My compiler was ~9,000 lines in the end. The first two phases were very easy, while the last two phases I spent at least 100 combined.
The lectures are good. The textbook was interesting, but it went much more in depth than the rest of the course, so it didn't feel particularly useful. The homework is very disconnected from the project and focuses on the theory.
The final is a very large portion of your grade, but the questions are similar to the homework`,rating:5,difficulty:5,workload:40},{user:"LefJrbGb0JcEykix98KsUQ==",reviewDate:"August 7, 2023",semester:"summer 2023",review:`I was interested in this subject, and the class did not disappoint. Really interesting content that makes you realize how applicable theory can actually be for something software engineers use on a daily basis. While previous reviews from years ago seem to indicate TAs gave ambiguous answers and the assignments are vague with requirements, that was not the case this semester (and is probably no longer the case); TAs were absolutely fantastic and the grading for the project was very fair - you could have a very good idea of your score with the autograder.
While many may understand the general phases of a compiler, there was a lot more to them than I expected; things like NFA/DFA conversions and minimizations, liveness analysis, (super)local value numbering/other optimizations, and NP-complete graph coloring problem for register allocation are examples of things I had never heard of.
This class does not delve too much into compiler optimizations because there is so much content to cover to just to explain what a compiler does at a high level. In the summer, the content is reduced even further (less requirements for the project). Unfortunately, the continuation of this class that dives into advanced optimizations is only offered in person, but I hope to see it for OMSCS in the future.
General advice:


Read the textbook if you want to maximize learning (and get the 2nd edition if they're still requesting that, since there is some content that has been removed/rearranged in the 3rd).


The homework and exam questions were honestly more difficult than the project. Building a compiler is a long process, but after you know what to do and as long as you manage your time it's fairly straightforward (and I think the LOC in other reviews are somewhat of an exaggeration; the amount of code I wrote didn't total to be over 5000 lines, and that includes very inefficient modularity). Free response questions are human error prone and most of the points I lost were from careless mistakes.


Ways this class could be improved:


I feel like making the final exam 35% of the grade put a lot of stress on me; potentially giving more weight to the homework (which are similar to the exam) could alleviate some of that pressure.


Perhaps the timing is made a little off in the summer just because of the shortened term, but there were cases where I had to watch/read ahead of schedule to finish homework at a comfortable pace. If the homework is opened earlier (or there was at least corresponding sections explicitly stated that we should read/watch before completing it) I think it would've improved the experience.


Probably the most interesting/fun class I've taken so far, but I think you kind of have to be interested in the topic to begin with. This class made me more interested in this topic.`,rating:5,difficulty:4,workload:16},{user:"RuW3kVPIXMNseTxU8DcUoQ==",reviewDate:"August 6, 2023",semester:"summer 2023",review:`I'm really glad I took this course. I'm really glad it's over now.
This does what it says on the tin. You build an end-to-end compiler with generated scanner/parser, semantic checking, IR generation, a limited amount of optimisation, register allocation, and instruction selection. From scratch, with no starter code. You also have chunky homework due every other week. And an exam that does actually take the three hours they give you.
I learned an absolute ton. It demystified some big topics. It helped me understand how some of the people at work had approached some interesting issues. And it's very satisfying when your compiler makes the code run as intended at the end.
The downside is that this class is a full time job. I only stayed sane because my team was laid off earlier this year and I'm not working at the moment. It ate my life, especially the last month. I'm usually sceptical of reported timings on OMSCentral because they seem to be skewed by less experienced candidates. As far as I can tell, those people don't tend to take this class. I was a senior SWE at FAANG and it took me 25-30 hours a week. And it won't be much better in spring/fall because you could see several points where they stripped out big requirements to fit the summer semester.`,rating:5,difficulty:5,workload:30},{user:"jqq7OxRh9cZ83cz7T7jnzQ==",reviewDate:"August 2, 2023",semester:"summer 2023",review:`Broadly speaking, this course is a good introduction to how a compiler works. Implementing one from beginning to end (kind of, you still leverage a parsing framework) is a great way to learn the broad stages of compilation and should help you feel a bit more connected to what's happening under the hood when you type make.
That said, my biggest gripe with the course is that it didn't really get into any of the interesting meat of modern compilers. For example, a compiler frontend isn't particularly complex - yes it's nice to cover how a compiler might traverse a parse tree to perform semantic checking, build a symbol table, and emit corresponding IR instructions, but these are just not that difficult and are pretty well-solved problems. 2 of the 3 project phases focused on the frontend, when it really should have just been 1. These can be condensed just by simplifying the language a bit - the (relative) complexity of the current Tiger language adds a lot of tedious work without much learning benefit.
Meanwhile, the project barely covered what modern compilers really focus a lot of energy on - optimization! The only degree to which the project covered optimization was in implementing a register allocator (which is really only an optimization relative to...not using registers). I really think the project's phase 3 (implementing the backend) should have been phase 2, and phase 3 should have focused on optimization in much more depth. It should have at least covered things like live range splitting, dead code elimination, constant propagation, and perhaps inlining. The grading should have a minimum performance requirement. Currently, the only degree to which performance is evaluated is in an optional class competition (with the winner receiving some extra credit).
Ultimately, if you've been a software engineer for some amount of time, you've likely been exposed to and made aware of many compiler optimizations to keep in mind as you write code. This course will not actually teach you much about how to implement these optimization as I had hoped. If you're a bit earlier in your career, or just have not really been exposed to a compiler aside from clicking "build", then it's a solid introduction.`,rating:2,difficulty:3,workload:15},{user:"knlR4vniShLAQhvgS5zc2g==",reviewDate:"May 4, 2023",semester:"spring 2023",review:`I took this class without having had any undergrad compiler exposure. I doubled up with Computer Law, which was a perfect choice (low effort and no timing overlap).
I prepared well for the class and it served me well:

Learned about DFA, NFAs & Regular languages by completing half of the Stanford Automata Theory course: https://online.stanford.edu/courses/soe-ycsautomata-automata-theory. The Automata course is not necessary as the compilers course goes over DFAs and NFAs in great detail, but it helped me get a head start and also understand it deeper (there are no proofs in the compilers class, while the Stanford Automata course actually explains the why.  E.g why do DFAs, NFAs and regexes have an equivalent representation? In the compiler class, you are just asked to transform between those representations without explaining why that is possible)
Created a skeleton ANTLR visitor compiler + Grammar in Java using this awesome Youtube tutorial: https://www.youtube.com/playlist?list=PL5dxAmCmjv_4FGYtGzcvBeoS-BobRTJLq
I took HPCA in previous semesters, hence I was familiar with the basic MIPS instructions. An understanding of computer architecture is maybe not necessary but helped me to understand some concepts better.

I worked alone and that worked out great. Also, it seems like most teams of two did not 100% finish the last part of the compiler.

No communication or coordination needed. I worked weeks ahead of the lecture schedule and also started implementing the next part of the project before it was released.
I did not write unit tests (that's problematic if you work with someone else)

Tipps

Make sure to understand the homework well. You'll do the same stuff in the exam under time pressure.
Do the homework using pen-and-paper, but when possible, verify using code/your compiler. For instance, we had to do live range analysis and register allocation for the homework. My compiler already had that functionality implemented so I could double-check my results. Therefore you benefit double from working ahead of schedule.

Things I disliked:

Lecture quizzes were too simple and did not prepare well for the homework. The homework is difficult and requires you to understand the subject well.
Consider releasing the homework earlier. In order to code up the projects, we had to understand the lecture material weeks ahead of schedule at times. I had to re-learn the content weeks later to complete it.
The lectures are frustrating at times. The professors' accent, grammar, and explanations at times impeded my understanding of the subject. The book on the other hand was very precise and more understandable.

I also disagree with previous reviews that claim that we are not taught how to implement register allocation (virtual -> physical registers) properly. We were shown how Brigg's algorithm works and where then asked to implement it in the project.
By the same token, instruction selection (IR instruction -> MIPS instructions) was not as impossible as other reviews make it out to be. Make sure to understand a MIPS calling convention (this is the excellent one I implemented: https://courses.cs.washington.edu/courses/cse410/09sp/examples/MIPSCallingConventionsSummary.pdf) and how the stack has to be created from it using offsets from the stack pointer. You don't have to translate loop constructs or something like that into MIPS, as that has already been done in the IR. Most IR instructions have a 1:1 MIPS translation, but not all - but you'll figure that out during the implementation.
Each part of the compiler is also easy to test, as we are provided with the necessary tools to do so (test suite for part 1, IR interpreter for part 2, QTSpim and test cases for part 3).
Overall, if you are motivated to learn the foundations of compilers, even if you do not have previous exposure, this is an excellent way to do it. Writing a compiler from scratch is intimidating at first, but looking back, it's no different than any other software project (and that perspective is exactly what I was looking for taking this course).  I encourage anyone to take this class if they are willing to put in the effort.`,rating:5,difficulty:5,workload:30},{user:"Georgia Tech Student",reviewDate:"December 16, 2021",semester:"fall 2020",review:`Take this course if you want to learn how compilers work end to end, and if you have the time to dedicate to it.
This class is great for breadth and gaining practical experience in how compilers work. A large time portion of the class is spent on the coursework which involves writing a compiler from scratch
The best part about the coursework is that the problems are ambiguous and don't just involve execution, this makes it challenging and parallel with real life. Additionally i loved that we get to create the entire compiler from scratch (other than using parser generators on the frontend which is how it's done in practice) - this gives a full breadth of knowledge on different parts of the compilation process
Improvements:

As other reviews have mentioned the assignments don't need to be as elongated as they are and involve a lot of hand written manual solutions
The exam carries around a third of the overall weighting which is hugely disproportionate to the amount of time spent on the coursework and it's mostly just a repetition of the assignments it would have been a better approach to drop the exam entirely and give more time to the coursework, for example covering optimisation
`,rating:5,difficulty:4,workload:30},{user:"Georgia Tech Student",reviewDate:"December 16, 2021",semester:"fall 2021",review:`I loved this class. It's an excuse to implement a bunch of really interesting algorithms.
Advice:

Be completely comfortable coding in whichever language you're going to use (Java or C++) because the project is thousands of lines of code, written from scratch with no skeleton / starter code. It's a lot of work, even for those of us who've been programming a long time, so you don't want to be struggling with fundamentals.
Write code to answer the homework problems for you. Doing them by hand is way less fun and far more error-prone.
Don't take this unless you're pretty interested in the topic. To reiterate, it's a ton of work.

Complaints: The final is a large part of the grade, there's no study guide and no previous quizzes or tests to tell you what to expect, and it's very tough. I didn't feel like it added anything to the class except stress.`,rating:5,difficulty:4,workload:20},{user:"Georgia Tech Student",reviewDate:"December 13, 2021",semester:"fall 2021",review:`My main issue with this course is that there is too much mundane and tedious work. I feel like I could've learned 80-90% of the material through doing only 50% of the assigned work; in other words, the amount of content learned per hour of work in this course is very low.
For example, some of the homework and exam questions require running algorithms by hand on programs of substantial size. An analogy would be, imagine in an algorithms course you get a homework question that is run Dijkstra's by hand, showing each step, for a graph with 50 vertices. Does it help the student learn? Sure. But is it efficient in doing so? No.
Same goes for the project. I do get that writing a full compiler from beginning to end is cool, but there are parts of the project that were huge time sinks but didn't teach me much about compilers. One example: having to write dozens of if-statements to account for global vs. local, array vs. scalar, float vs. int and various combinations of these for assign and other instructions in phase 3. I would suggest stripping out some of the complexities that are time-sinks but aren't that valuable in terms of learning.
TA's are very responsive and helpful though.`,rating:2,difficulty:5,workload:40},{user:"Georgia Tech Student",reviewDate:"November 25, 2021",semester:"fall 2021",review:`DO NOT TAKE
The amount of time and energy this course requires is orders of magnitude greater than what you will learn, and take away from the course. You might think: "I'm a professional software engineer, it shouldn't be that bad for me". Perhaps the concepts will be easier for you, but there is no escaping the work load. It's like a second job where you don't get paid, and you have to work nights, weekends, holidays, and especially while you take vacation from your other job.
Project
The main problem with this class is the project. I am not even done with the project, and my code base is over 9,000 lines of C++. You have to implement a compiler using C++ or Java, making use of an Antlr4 lexer/parser generator. This Antlr thing was clearly meant for Java developers, as the C++ examples and documentation are very scarce. There are also some bugs in the C++ interface which can trip you up for hours. The compiler you are tasked to create supports the "Tiger" language. It would be nice if the language was more "Toy". This language is moderately complex in that it supports global statics, local variables, arrays, floats, integers, and integer promotion to float. Plus the usual full suite of operators. This means that there is heavy case analysis in the code. The last disappointing part of the project is the fact that you must generate assembly code in MIPS. MIPS is a dead language, yet I've been spending weeks of my life figuring out how it works.
Homework
The homework for this class is also very involved, and each one can take a full week of effort (There are 4). They are manually graded, and require drawing up a lot of diagrams. The homework is more reasonable than the project, because it forces you to watch the lectures, and apply the learning at a smaller scale.
TAs
The TAs for this class are fantastic. They frequently provide great feedback via Ed discuss, and they grade fairly. The trouble is the TAs cannot debug your 9,000 lines of code for you.`,rating:1,difficulty:5,workload:48},{user:"Georgia Tech Student",reviewDate:"August 23, 2021",semester:"summer 2021",review:`This was a fun course for me personally and hits a programming bucket list item (write a compiler), so I was very motivated to take this course. It was a big challenge and took a toll on my psyche but I ultimately don't regret it since I needed some extrinsic motivation to go through with an undertaking like this.
Pros

If you like project-focused classes, this is probably the biggest one - the whole semester you write a compiler in phases (lexing/parsing, semantic analysis/IR codegen, machine codegen).
I can't understate the value of learning how compilers work end-to-end. It really helps turn compilers from magic black boxes to something you can conceivably understand and use to your advantage, as either a compiler writer or someone optimizing code.
You can use Java or C++.
TAs were very helpful and kind.
The homework mostly helped build understanding of some of the concepts needed to implement the compiler.
Feedback from the autograder was useful and the grading on the project wasn't too all-or-nothing.

Cons

Optionally a group project. Be very careful - the overhead of collaboration can hurt you more than it helps you sometimes.
There is a certain amount of irreducible complexity and labor associated with writing an entire compiler from scratch, so it always feels like there is just too much work to do a good job on each phase of the compiler.
The project is open-ended, but has no supporting boilerplate code. You write everything from scratch, and that burns a lot of time exercising skills that don't get you a better grade (argument parsing, assembling your build system, etc).
Dr. Pande's grading schemes are kind of brutal. The compiler has a good grading suite but the homework assignments and final exam feel tedious (especially doing live variable analysis by hand on complex programs, that felt downright sadistic after having implemented it in code 3 separate times already).
Both the lectures and textbook don't fully explain concrete strategies for implementing instruction selection, so almost every team failed to do that step completely right. Having at least some material on how to handle mapping from virtual to physical registers in MIPS when you have multiple different register allocation algorithms in play would help, a lot. Even just some prewritten material providing common ways of implementing various constructs in MIPS (loops, function calls, recursion, etc) without stomping on your own registers would have helped.
`,rating:4,difficulty:5,workload:40},{user:"Georgia Tech Student",reviewDate:"July 27, 2021",semester:"spring 2021",review:`This is a light version of compiler course comparing CS6241-A. Because of the time limitation, it does not touch interesting LR parser and other topics in backend. Lecturer is very knowledgeable to compiler world; bad thing is the semester is too short that you can't learn too much from him.
The project is also a short version of compiler for Tiger Language. It covers a full cycle of compiler phase from source code to assembly but it doesn't include loader. ANTLR is used as the compiler framework, instead of LLVM being used at CS6241-A, it's fine for people who want to learn compiler, but you might want to study LLVM if you really want to work on compiler world in the future. The setting for the project is clear but not optimized. The final project asks to get the least number of machine instruction; which makes students choose some uncommon mechanism to optimize their code.
Pro:

You get touch on the full cycle of a compiler implementation.
Project is fun and challenged.
If you want, you can explore a lot more on compiler theorem.

Con:

Semester is too short for people who has no compiler background.
Project could be challenged for the student who has no CS background and don't know MIPS
`,rating:5,difficulty:5,workload:20},{user:"Georgia Tech Student",reviewDate:"May 19, 2021",semester:"spring 2021",review:`What a great course! The reward is definitely proportional to the workload, as is true with most of the great OMSCS courses. The material is pretty introductory as far as compiler theory goes; you won't cover any crazy optimizations or more complex language features, but you will master the fundamentals of compilation in theory and practice (or else this course will eat you alive).
First, the lecture/textbook material:

I found the lectures to be very helpful and clear, even despite some minor errata. The course staff are good about providing addenda correcting any errors.
The textbook was neat and had a lot of good info in it, but I didn't find it to be absolutely necessary; most of the exam/homework material relied more heavily on the lectures. Good for background, but I personally didn't find it vital to read the book.

The homework and final:

The homework assignments took a fair amount of time and thought, and I found that a careful attention to detail was vital for each of them (many of the questions involve stepping through a particular algorithm manually and displaying state at each individual step; I found it necessary to check and recheck my work to make sure no typos led me to the wrong answers). That being said, they were interesting, stayed centered around the core concepts, and were good preparation for the final exam.
The final exam was fairly challenging in a vacuum, but I found it to be a decent continuation of the homework assignments. There weren't many surprises, but I still felt like the exam was a challenge. As long as you really put effort into the homework assignments and keep up with the lecture material, you'll be in pretty good shape.

The project(s):

The project in this class is super cool. You pretty much start from nothing and build a working compiler.
By its very nature, building a compiler is a very complex undertaking, even a toy compiler like this. Starting early on the project phases is mandatory.
You have the option to work with a partner, which I recommend, given the amount of work required.
Looking at past reviews, it does appear that the project has gotten some reworks. A significant portion of the work is autograded, so you'll get feedback on how things are running long before the deadline. In addition, the rubric is quite clear and well laid out (no "random" grading that I saw). In addition, the project makes use of some more modern parser generator tools, so you won't be manually implementing a scanner or parser or anything like that.

The staff/logistics:

Professor Pande and the TAs were all very helpful and responsive. The team behind this course is very knowledgeable and genuinely interested in seeing you succeed.
My only gripe with this course has to do with the pacing. I found that the homework and project deadlines didn't line up very well with the material being covered each week. In some cases I found myself needing to understand a concept or algorithm from a lecture three weeks ahead in the syllabus in order to implement the project in a timely manner. Not sure there's any way around this, but I found that I needed to really manage my time carefully to account for the gap.

Overall, I highly recommend this course. I don't think that my experience lines up with it being "the most difficult course in OMSCS," and I encourage anybody who's scared off by its reputation to reconsider and give it a try!`,rating:5,difficulty:4,workload:15},{user:"Georgia Tech Student",reviewDate:"March 19, 2021",semester:"spring 2021",review:`It's a tough class with demanding project. I had to take 2 days off work to finish first project on time, but I worked alone without group. I wouldn't suggest taking this if you don't have much of programming/CS background. My tips would be to learn as much as possible about graph and graph algorithms, ANTLR4, and MIPS. that way you can have more time to spend actually doing the project and the course will be more enjoyable. Also, learn how to use makefile, I spent stupid amount of time trying to get my project working.
Pros:

You will learn something that is actually useful.

Cons:

The project is kind of big, naturally there are many ambiguities and it's your responsibility to confirm everything in piazza. (if the assignment is more properly described I'd give this course a strong like)
`,rating:4,difficulty:4,workload:30},{user:"Georgia Tech Student",reviewDate:"December 3, 2020",semester:"fall 2020",review:`This is by far the most rewarding course I've taken in OMSCS so far. Do not get scared by the other reviews on this page or what people on Reddit say. If you really want to maximize the ROI of the Masters and are not just in it for the diploma, take this course. This felt like a true Master's/graduate level course that really challenged me and was not just a "check the boxes" kind of course.
You will essentially build a compiler from scratch in either Java or C++. You will intimately know all the theory and practical details of what makes up a compiler and will really give you a solid foundation as a software engineer. I really noticed this towards the end of the semester when I took a look at the GCC source code and realized that I understood at a high level how the different GCC phases worked. I then looked at LLVM and really understood for the first time why it's so powerful.
I also applied these concepts to my day-to-day job as a full time software engineer, where I created a transpiler to help upgrade our code from one JS framework to another automatically. I noticed that this knowledge helps me pick up new programming languages faster because I know what the foundational elements of a language are now. It is also another way to think about solving problems.
I will agree that it is a large commitment, but the more you invest into it, the more you will get out of it. I did the projects alone (can be done in teams) because I wanted to really understand everything from end-to-end. Attend the office hours to get all your curious questions answered. The book is very helpful and deep dives into what the lectures do not cover.
Again, this course is not for those who are in it for the easy A or the diploma. This course is for those who are genuinely curious about what happens in the blackbox of compilers and really want to dive under the hood to understand them. This course will not hold your hand, but if you're really invested and do the readings and work hard on the projects, I promise you'll come out the other end really understanding compilers, assemblers, transpilers, linters, linkers, finite state machines, ASTs, and much more.`,rating:5,difficulty:5,workload:20},{user:"Georgia Tech Student",reviewDate:"May 31, 2018",semester:"spring 2018",review:`Good:

Very practical. The projects use industry-standard compiler tools and algorithms, so you could easily apply the knowledge gained in this class elsewhere if you needed to.
You will (most likely) learn a LOT. It is impossible to make it through this class without deeply understanding the parts of the compiler you're supposed to implement (lexing, parsing, symbol table generation, semantic analysis, IR generation, register allocation, instruction selection), the abstractions used under the hood (regular languages, context-free languages, parse trees, attribute grammars, control flow graphs, SSA, live ranges, live webs, etc.).
The 4 written homeworks were relatively short, but very topical, and struck a good balance between reinforcing the practical things we had to know for the projects and complementing them with the theoretical things we learned in lectures.
When you're done, you'll be happy you took it (if you were able to make it).

Bad:

The professor is uninvolved, and the TAs run the show. However, at least my semester, the TAs were distinctly unhelpful.

Answers on Piazza were vague; project descriptions were underspecified or flat out wrong (this is not an opinion - one of the requirements of the first project was provably impossible, and when I pointed this out to the TAs, they were unable to understand the issue, despite agreeing with me that it was impossible).
It turns out that compilers are extremely detailed, and those details are really important; expect to spend a lot of time looking for clarifications that may or may not be provided. We had to just make arbitrary decisions on a lot of issues, and document those decisions in our writeup.


The 2 projects are both group projects (3 person teams), and you must have the same group for each project (since project 2 builds on project 1).

The only allowed languages are Java and C++. Be very comfortable in at least one of them.
The projects are both large enough that you can afford to have 1 slacker, but not 2.
The projects are sizable enough (i.e. 10,000+ lines of code) that you will either learn/use good software engineering practices, or fail. Again, your group composition can make or break you.
Both projects are "green field" projects, meaning there is no starter code, no push in the right direction. This is a double-edged sword because it forces you to think about the design you want, but it's definitely less forgiving than it could be.



Overall, this class wouldn't be that hard, if it weren't for the projects (which I hope get reworked). The material is interesting, and it's useful to be able to imagine the internals of whatever compiler you happen to be using (e.g. for work) so you can structure your code to provoke certain optimizations.`,rating:4,difficulty:5,workload:35},{user:"Georgia Tech Student",reviewDate:"May 6, 2018",semester:"fall 2017",review:`If you take this course without having taken the undergraduate equivalent, you will be in for a wild ride (i.e. what are you doing here, walk away slowly). Per other descriptions, you will be implementing an entire compiler!
Pros:

The lectures are very good and don't cover useless material like other courses (cough, cough, CV).
The projects are useful. You will get an actual compiler at the end of the day.
There's no hand holding while creating the compiler - you will build everything from the ground up.
The TAs (now gradudated) responded almost instantly on Slack and Piazza.

Cons:

The HW is graded far too rigorously.
The actual project is haphazardly graded (i.e. they're not using a rubric so you will get a somewhat random grade).
The project specification is so vague that you will be constantly asking for clarification on Piazza. This was nerve wrecking and frustrating. The lack of professionalisim on behalf of the TAs made this worse.
`,rating:4,difficulty:5,workload:20},{user:"Georgia Tech Student",reviewDate:"April 6, 2018",semester:"fall 2017",review:`PROS:

If you are interested in this material, it is a good class in terms of what is being taught. You will build a compiler from the ground up.
The grading was generous.

CONS:

You better learn about registers and memory on your own because it is NOT covered in the least. A lot of times is spent on parsing, regex, languages, etc. and zero time is spent on the technical part of a compiler.
As another reviewer said, the course is run mostly by the TAs. When I took it, there was one very vocal TA in that they were active on Piazza and Slack, but their answers were TERRIBLE. When I realized this, I tried phrasing my questions as yes\\no or as multiple choice, to try and steer them towards actually answering them, but never did they just give me an answer!
The professor participated in office hours, but had no idea what the current homework was. He would be asked a question and would have to look at the homework as if it was the first time he's ever seen it. The homework had plenty of typos and ambiguities.
All the answers, from the professor and the TAs were always so laconic. This is an online class based mostly on text. This is a place to answer in full sentence and elaborate, or else what is the function of having a class vs. just having lectures?
The lectures are very general, so not very helpful for the homework and the project.

This class makes all other classes I've taken before and after seem like a dream.`,rating:1,difficulty:5,workload:20},{user:"Georgia Tech Student",reviewDate:"December 19, 2017",semester:"fall 2017",review:`This is an incredibly difficult class with a very large time commitment. The lectures are dense but helpful for the most part. These lectures gloss over some details which force you to read the book which has moments of utility but is by and large, a jargon-riddled dumpster fire. The book uses some dreamed up syntax to express some of the algorithms which is pretty taxing to understand. The best approach is just to re-write the algorithm in code into you get the results you expect. The homework is very difficult because the questions are vague but expect precise answers. Fortunately, if you head my advice for dealing with the text book, you can use the same approach and produce code to solve your homework. You don't get credit for the code but it certainly make producing nice LaText and reduces the chance of you transliterating something in your process. If you can explain your approach, you might be able to retain some points but overall, the homework grading is very strict. The coding portion of the project is massive. Absolutely massive. I think it should have been split into at least 3 projects but that may have slowed the class down and there is a lot of ground to cover. I have no complaints about the project grading or what they asked of us. The project document is pretty vague and you have to interpret and justify a lot of your design decisions, just like in real life :)
The final was not fun and was pretty much like the homework. Treat the homeworks like a practice exam in order to get a feel for the final. The final grading has a decent curve so don't give up, always submit at least something. The way the assignments are weighted, you can't afford to skip any single task.`,rating:4,difficulty:5,workload:35},{user:"Georgia Tech Student",reviewDate:"December 19, 2017",semester:"fall 2017",review:`The first pre-requisite of this course is patience. Lectures are long and intense and the project is also very long, but you get to learn. Homeworks require pen and paper work but are interesting and not as hard as project. Final is said to be consisting of some MCQs and some essay type questions, but what we got are 3 MCQs (worth about 10%) and rest problems. Final is similar to homework problems.
There are a few logistic issues like you dont have a practice exam or you dont know the cutoffs for grades, but overall it was a decent course. Grading is not that strict, but cutoffs are high (not as high as absolute grading).
Being patient and not giving up will be rewarded in this course.`,rating:4,difficulty:4,workload:25},{user:"Georgia Tech Student",reviewDate:"August 6, 2017",semester:"summer 2017",review:`This was a fantastic course. The lectures, HW, projects were self sustaining and HARD, but you will walk away a much better programmer and have had an opportunity to really apply topics related to computer science. I loved the course topic and organization so much, that I may take it again in Spring or Fall at some point in future.
The projects require a SOLID understanding of C++ or Java, and if you are not an super start programmer with strong data structure and algorithm skills you will need a VERY STRONG partner. This class is not watered down at all, and partially what made the class so great. If this course is a reflection of the Professors other courses, I plan to take all of them.`,rating:5,difficulty:5,workload:50},{user:"Georgia Tech Student",reviewDate:"July 24, 2017",semester:"summer 2017",review:`Excellent course: content, organization, staff, and programming assignments.
Very interesting to learn how code is compiled, and how compilers optimize the code internally to make it more efficient. The course covers all compilers phases. Lectures are crystal clear. Professor has been very committed to the office hours (weekly), open to different types of question. TA is very prompt, rarely let a day pass with unresolved piazza questions, with clear concise answers.
Programming projects! Not for the faint of heart. Implemented either in C++ or Java. No starter code. As I understand, the summer version of the projects is a bit different than Fall/Spring which included more compiler phases but with starter code. Be very well prepared with one of those 2 languages. And explore data structures, you'll need to use lots of sets, vectors, stacks,... etc as well as structs. Projects can be done solo or in teams of 2, but we were strongly advised to work in teams. And having taken the solo option and spent tons of time to keep up with this choice, I recommend you find a team mate unless you're an experienced programmer.
There are 2 projects, the first is a front-end project where you implement a simple scanner, and implement a parser generator and an LL(1) parser. The second project was much harder, where you implement 3 methods of register allocation on IR code and convert the code into assembly, and simulate the assembly using SPIM simulator.
There were 4 HWs, that take a bit of time, pen and paper work, but they were excellent in measuring how well you undrstand the material.
There's a final exam, haven't taken it yet, but it should cover the entire syllabus.
As I remember Projects: 35%, HW; 35%, final exam: 30%
Perhaps the only con would be the absence of an auto grader, and being given basic tests to try our code against, you will have to devise your own tests, otherwise risk failures with the grading tests.
Highly recommended.`,rating:5,difficulty:5,workload:30}],reviewSummaries:{"summer 2024":"The course received high praise for its comprehensive content, combining theory and practical application, which significantly enhanced understanding of compilers. The TAs were highlighted as a major strength due to their expertise and quick response times. However, some students noted that certain course materials, like the attribute grammar framework, felt outdated. While the project was regarded as challenging yet rewarding, with ample feedback from autograders, it was also noted that the final exam was disproportionately weighted, especially given the course workload. Students generally recommended taking the course, but preparing for significant coding demands, especially in Java or C++, was emphasized. Overall, it’s considered a valuable learning experience, though intensive.","spring 2024":"The course is challenging but rewarding, with many students enjoying the experience of building a compiler from scratch using C++ or Java. While some found it easier than Distributed Systems, others appreciated its engaging nature, particularly when paired with Software Analysis. The project phases vary in difficulty, with the initial ones being manageable, but later phases requiring significant effort. Lectures are deemed beneficial, although the textbook is considered overly detailed and not directly useful for the course. Homework assignments feel disconnected from practical projects and focus on theory, while the final exam constitutes a substantial part of the grade, echoing homework questions. Overall, students recognized the course's benefits despite its demanding nature.","summer 2023":`The course offers engaging content that effectively connects compiler theory to practical software engineering, with many students appreciating the detailed approach to building an end-to-end compiler. Feedback highlights the improvement in TA support and fair grading. However, the course demands significant time investment, often described as a "full-time job," which can lead to stress, particularly with the weight of the final exam. While many found the class fascinating, especially those already interested in compilers, others expressed disappointment regarding the lack of depth in modern optimization techniques and felt certain project phases could be streamlined. Overall, it's a solid introduction for early-career engineers but may leave seasoned engineers wanting more on advanced topics.`,"spring 2023":"The course on compilers offers both strengths and weaknesses. Positively, students appreciated the thorough coverage of DFA, NFAs, and regular languages, with supplementary resources enhancing understanding. Many found the project components engaging, especially when working independently, which allowed for flexibility and deeper comprehension of topics like register allocation. However, critics pointed out that lecture quizzes were overly simplistic, failing to align with the challenging homework. Additionally, some students struggled with the professors' clarity and suggested that homework be released earlier to facilitate better learning pacing. While there were concerns about the complexity of certain implementations, overall, motivated learners found the course a rewarding experience that effectively teaches compiler foundations.","fall 2020":"The course offers an in-depth exploration of compiler construction, providing practical experience as students build a compiler from scratch. Reviewers praise the challenging coursework, which mirrors real-world scenarios, and the comprehensive understanding gained in both theory and practice. The hands-on approach is particularly rewarding for those genuinely invested in mastering the subject. However, criticisms include the excessive length of assignments and a disproportionate exam weight that many feel detracts from the focus on coursework. Some reviewers suggest eliminating the exam to allow more time for topics like optimization. Overall, this course demands a significant time commitment but offers substantial rewards for dedicated students.","fall 2021":"Reviews of the course are mixed, highlighting both engaging elements and significant drawbacks. Students enjoyed the opportunity to work with interesting algorithms and appreciated the responsiveness of the TAs, who provided helpful feedback. However, many felt overwhelmed by the workload, describing it as akin to a second job with extensive coding requirements—particularly for the project, which involves implementing a complex compiler that can lead to massive codebases and tedious debugging. Complaints centered on the time-intensive nature of assignments, which some felt taught little compared to the effort required. Additionally, the final exam was criticized for being difficult without sufficient preparatory resources, adding to participants' stress. Overall, the course demands a high commitment with questionable rewards.","summer 2021":"The course received positive feedback for being engaging and project-focused, allowing students to write a compiler in phases, which demystifies the compiler process. Many appreciated the helpful TAs, valuable homework assignments, and useful autograder feedback. However, challenges were noted, such as the heavy workload and complexity of creating a compiler from scratch, which can be overwhelming. The optional group project might add more stress than benefit, and grading, particularly from Dr. Pande, is perceived as harsh. Additionally, students felt that the lectures and textbook lacked sufficient detail on crucial aspects like instruction selection, leading to widespread struggle in implementing key features. Overall, the course is a mix of rewarding experiences and considerable difficulty.","spring 2021":"The compiler course offers a solid introduction to compiler theory with practical projects using the ANTLR framework. Students appreciate the engaging lectures and clear project guidelines, which effectively cover the full cycle of compilation, making the learning experience enjoyable. However, the course is criticized for its short semester, making it challenging for those without a strong programming or CS background. Many reviewers recommend prior knowledge in graph algorithms, ANTLR, and MIPS to handle the demanding projects. While some feel the workload is demanding and required them to spend significant time on projects, the course staff's support and the comprehensive nature of the tasks are frequently highlighted as positives. Overall, it’s a worthwhile course for those prepared to invest the effort.","spring 2018":"The course offers a practical and in-depth look into compilers, providing valuable knowledge applicable in the field. Many students appreciate the challenging projects, which require a solid understanding of both theoretical concepts and hands-on skills, ultimately leading to a rewarding experience. However, the professor's lack of involvement and unhelpful TAs have led to frustrations, particularly regarding vague project descriptions and insufficient guidance. Clarification on project requirements can be difficult to obtain, leaving students to make arbitrary decisions. Group dynamics are crucial due to the size and complexity of the projects, which can be challenging without a reliable team. Overall, while the material is intriguing, the execution of the projects may need significant improvement.","fall 2017":"The course on compiler construction is both challenging and rewarding, noted for its comprehensive lectures that avoid extraneous material and effectively guide students through building a compiler from scratch. Positive feedback highlights the utility of projects, responsive TAs, and generous grading. However, many students express frustration with the grading rigor on homework and vague project specifications, leading to confusion and a lack of clarity in assignments. Some also criticize TAs for inadequate support, and the textbook's complexity adds to the struggle. Overall, the course demands significant time and patience, but those who persevere find valuable learning experiences, despite encountering issues with communication and resources.","summer 2017":"The course received high praise for its challenging and well-structured content, providing a solid understanding of compilers and programming constructs in C++ or Java. Students appreciated the clarity of lectures and the commitment of the professor and TAs, who were responsive and available for support. Projects were considered demanding but valuable, emphasizing teamwork and requiring strong foundational programming and algorithm skills. However, some reviewers noted the difficulty of the assignments and the absence of an auto-grader, which made testing code against provided criteria a challenge. Overall, the course was highly recommended for those prepared for rigorous academic work, with many considering taking it again due to its effectiveness in enhancing programming abilities."}};export{e as default};
